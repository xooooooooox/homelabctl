name: Attach release packages

on:
  workflow_run:
    workflows:
      - Build COPR package
      - Build OBS package
      - Update Homebrew Tap
      - Build Portable Binary
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

jobs:
  attach-release-packages:
    if: >-
      ${{
        github.event_name != 'workflow_run' ||
        (github.event.workflow_run.conclusion == 'success' &&
        (github.event.workflow_run.head_branch == 'main' ||
         startsWith(github.event.workflow_run.head_branch, 'workflow/')))
      }}
    runs-on: ubuntu-latest
    env:
      COPR_PROJECT: ${{ secrets.COPR_PROJECT }}
      OBS_PROJECT: ${{ secrets.OBS_PROJECT }}
      OBS_PACKAGE: ${{ secrets.OBS_PACKAGE }}
      OBS_API_URL: ${{ secrets.OBS_API_URL }}
      OBS_USERNAME: ${{ secrets.OBS_USERNAME }}
      OBS_PASSWORD: ${{ secrets.OBS_PASSWORD }}
      TAP_FORMULA_URL: https://raw.githubusercontent.com/xooooooooox/homebrew-radp/HEAD/Formula/homelabctl.rb
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Resolve tag and package
        id: release
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_run" ]]; then
            head_sha="${{ github.event.workflow_run.head_sha }}"
            tag_name="$(git tag --points-at "${head_sha}" --list 'v*' | sort -V | tail -n 1)"
          else
            tag_name="${GITHUB_REF_NAME}"
          fi

          version_file="src/main/shell/commands/version.sh"
          if [[ -z "${tag_name}" && "${GITHUB_EVENT_NAME}" == "workflow_run" ]]; then
            version_from_commit="$(git show "${head_sha}:${version_file}" | grep -oP 'declare -gr gr_app_version="\K[^"]+')"
            if [[ -z "${version_from_commit}" ]]; then
              echo "Failed to read gr_app_version from ${version_file} at ${head_sha}" >&2
              exit 1
            fi
            tag_name="${version_from_commit}"
          fi

          if [[ -z "${tag_name}" ]]; then
            echo "Failed to resolve version tag for event ${GITHUB_EVENT_NAME}" >&2
            exit 1
          fi

          if [[ ! "${tag_name}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Resolved tag '${tag_name}' does not match vx.y.z" >&2
            exit 1
          fi

          should_upload=true
          if ! git rev-parse "${tag_name}" >/dev/null 2>&1; then
            echo "Tag ${tag_name} does not exist yet; skipping release attachment."
            should_upload=false
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_run" ]]; then
            tag_sha="$(git rev-parse "${tag_name}^{commit}")"
            if [[ -n "${head_sha}" && "${tag_sha}" != "${head_sha}" ]]; then
              echo "Tag ${tag_name} points to ${tag_sha}, workflow head is ${head_sha}; skipping release attachment."
              should_upload=false
            fi
          fi

          version="${tag_name#v}"
          package_name="$(awk -F': *' '/^Name:/{print $2; exit}' packaging/copr/homelabctl.spec)"
          if [[ -z "${package_name}" ]]; then
            echo "Failed to read package name from packaging/copr/homelabctl.spec" >&2
            exit 1
          fi

          echo "tag_name=${tag_name}" >> "$GITHUB_OUTPUT"
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "package_name=${package_name}" >> "$GITHUB_OUTPUT"
          echo "should_upload=${should_upload}" >> "$GITHUB_OUTPUT"

      - name: Download COPR packages
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Build COPR package')
          }}
        env:
          VERSION: ${{ steps.release.outputs.version }}
          PACKAGE_NAME: ${{ steps.release.outputs.package_name }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${COPR_PROJECT:-}" ]]; then
            echo "COPR_PROJECT not set; skipping COPR download."
            exit 0
          fi
          python - <<'PY'
          import json
          import os
          import re
          import sys
          import urllib.parse
          import urllib.request
          from pathlib import Path

          copr_project = os.environ["COPR_PROJECT"].strip()
          version = os.environ["VERSION"].strip()
          package_name = os.environ["PACKAGE_NAME"].strip()

          if "/" not in copr_project:
            print(f"Invalid COPR_PROJECT: {copr_project}", file=sys.stderr)
            sys.exit(0)

          owner, project = copr_project.split("/", 1)

          def request(url: str) -> urllib.request.Request:
            return urllib.request.Request(
              url,
              headers={
                "User-Agent": "homelabctl-release-bot/1.0",
                "Accept": "application/json,text/html;q=0.9,*/*;q=0.8",
              },
            )

          def fetch(url: str) -> tuple[bytes, int, str]:
            req = request(url)
            with urllib.request.urlopen(req) as resp:
              data = resp.read()
              status = getattr(resp, "status", None) or resp.getcode()
              content_type = resp.headers.get("Content-Type", "")
              return data, int(status), content_type

          def api_json(url: str) -> dict:
            data, status, content_type = fetch(url)
            if not data:
              raise ValueError(f"Empty response from {url}")
            try:
              return json.loads(data.decode("utf-8"))
            except json.JSONDecodeError as exc:
              snippet = data[:200].decode("utf-8", "ignore")
              raise ValueError(f"Invalid JSON from {url}: {snippet}") from exc

          def download(url: str, dest: Path) -> None:
            dest.parent.mkdir(parents=True, exist_ok=True)
            data, status, content_type = fetch(url)
            if status >= 400:
              raise ValueError(f"Download failed: {url} status={status}")
            with open(dest, "wb") as fh:
              fh.write(data)

          params = {
            "ownername": owner,
            "projectname": project,
            "limit": "50",
          }
          builds_url = "https://copr.fedorainfracloud.org/api_3/build/list?" + urllib.parse.urlencode(params)
          try:
            build_data = api_json(builds_url)
            builds = build_data.get("builds") or build_data.get("items") or []
          except Exception as exc:
            print(f"Failed to read COPR build list: {exc}", file=sys.stderr)
            builds = []

          candidates = []
          for build in builds:
            if build.get("state") != "succeeded":
              continue
            source_pkg = build.get("source_package") or {}
            source_name = source_pkg.get("name") or build.get("package_name")
            if source_name and source_name != package_name:
              continue
            src_version = source_pkg.get("version")
            if src_version and not (src_version == version or src_version.startswith(version + "-")):
              continue
            candidates.append(build)

          if not candidates:
            print(f"No COPR builds found for {package_name} {version}", file=sys.stderr)
            sys.exit(0)

          selected = max(candidates, key=lambda b: b.get("id", 0))
          build_id = selected.get("id")
          repo_url = (selected.get("repo_url") or "").rstrip("/")
          chroots = selected.get("chroots") or []

          dest_dir = Path("release-assets/copr")
          downloaded = set()

          def fetch_listing(url: str) -> str:
            data, status, content_type = fetch(url)
            return data.decode("utf-8", "ignore")

          def download_rpms_from_listing(base_url: str) -> int:
            try:
              listing = fetch_listing(base_url)
            except Exception:
              return 0
            hrefs = re.findall(r'href=["\']([^"\']+)["\']', listing)
            count = 0
            for href in hrefs:
              if href in ("../", "./"):
                continue
              href_clean = href.split("?", 1)[0].split("#", 1)[0]
              if not href_clean.endswith(".rpm"):
                continue
              filename = href_clean.split("/")[-1]
              if filename.endswith(".src.rpm"):
                continue
              if package_name not in filename or version not in filename:
                continue
              if filename in downloaded:
                continue
              full_url = urllib.parse.urljoin(base_url, href_clean)
              try:
                download(full_url, dest_dir / f"copr-{filename}")
              except Exception:
                continue
              downloaded.add(filename)
              count += 1
            return count

          if build_id and package_name and chroots:
            build_dir_candidates = [f"{int(build_id):08d}-{package_name}", f"{build_id}-{package_name}"]
            for chroot in chroots:
              chroot_url = f"{repo_url}/{chroot}/"
              for build_dir in build_dir_candidates:
                direct_url = f"{chroot_url}{build_dir}/"
                download_rpms_from_listing(direct_url)

          if downloaded:
            print(f"Downloaded {len(downloaded)} COPR RPMs", file=sys.stderr)
          else:
            print(f"No COPR RPMs downloaded for {package_name} {version}", file=sys.stderr)
          PY

      - name: Download OBS packages
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Build OBS package')
          }}
        env:
          VERSION: ${{ steps.release.outputs.version }}
          PACKAGE_NAME: ${{ steps.release.outputs.package_name }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${OBS_PROJECT:-}" ]]; then
            echo "OBS_PROJECT not set; skipping OBS download."
            exit 0
          fi
          python - <<'PY'
          import os
          import sys
          import base64
          import urllib.error
          import urllib.parse
          import urllib.request
          import xml.etree.ElementTree as ET
          from pathlib import Path
          import time

          project = os.environ["OBS_PROJECT"].strip()
          package = (os.environ.get("OBS_PACKAGE") or os.environ.get("PACKAGE_NAME") or "").strip()
          version = os.environ["VERSION"].strip()
          api_url = (os.environ.get("OBS_API_URL") or "https://api.opensuse.org").rstrip("/")
          username = (os.environ.get("OBS_USERNAME") or "").strip()
          password = (os.environ.get("OBS_PASSWORD") or "").strip()
          max_wait_seconds = int(os.environ.get("OBS_WAIT_SECONDS", "1200"))
          poll_interval = int(os.environ.get("OBS_POLL_INTERVAL", "30"))

          if not package:
            print("OBS package name is missing", file=sys.stderr)
            sys.exit(0)

          def quote(segment: str) -> str:
            return urllib.parse.quote(segment, safe="")

          def request(url: str) -> urllib.request.Request:
            req = urllib.request.Request(
              url,
              headers={
                "User-Agent": "homelabctl-release-bot/1.0",
                "Accept": "application/xml,text/xml;q=0.9,*/*;q=0.8",
              },
            )
            if username and password:
              token = base64.b64encode(f"{username}:{password}".encode("utf-8")).decode("ascii")
              req.add_header("Authorization", f"Basic {token}")
            return req

          def fetch(url: str) -> tuple[bytes, int, str]:
            req = request(url)
            try:
              with urllib.request.urlopen(req) as resp:
                data = resp.read()
                status = getattr(resp, "status", None) or resp.getcode()
                content_type = resp.headers.get("Content-Type", "")
                return data, int(status), content_type
            except urllib.error.HTTPError as exc:
              raise ValueError(f"HTTP {exc.code} for {url}") from exc

          def fetch_xml(url: str) -> ET.Element:
            data, status, content_type = fetch(url)
            if not data:
              raise ValueError(f"Empty response from {url}")
            return ET.fromstring(data)

          def download(url: str, dest: Path) -> None:
            dest.parent.mkdir(parents=True, exist_ok=True)
            with urllib.request.urlopen(request(url)) as resp, open(dest, "wb") as fh:
              fh.write(resp.read())

          project_q = quote(project)
          package_q = quote(package)
          result_url = f"{api_url}/build/{project_q}/_result?package={package_q}"

          dest_dir = Path("release-assets/obs")
          downloaded: set[str] = set()
          deadline = time.time() + max_wait_seconds

          while True:
            try:
              root = fetch_xml(result_url)
            except Exception as exc:
              print(f"Failed to query OBS results: {exc}", file=sys.stderr)
              break

            candidates = []
            for result in root.findall(".//result"):
              repo = result.get("repository")
              arch = result.get("arch")
              if not repo or not arch:
                continue
              status_nodes = result.findall(f"./status[@package='{package}']")
              if not status_nodes:
                continue
              code = (status_nodes[0].get("code") or "").lower()
              if code in {"succeeded", "published", "finished", "unchanged"}:
                candidates.append((repo, arch))

            for repo, arch in candidates:
              repo_q = quote(repo)
              arch_q = quote(arch)
              base_url = f"{api_url}/build/{project_q}/{repo_q}/{arch_q}/{package_q}"
              try:
                binaries_root = fetch_xml(base_url)
              except Exception:
                continue
              for binary in binaries_root.findall(".//binary"):
                filename = binary.get("filename")
                if not filename:
                  continue
                lower = filename.lower()
                if lower.endswith((".src.rpm", ".nosrc.rpm", ".ddeb")):
                  continue
                if not (lower.endswith(".rpm") or lower.endswith(".deb")):
                  continue
                if version not in filename:
                  continue
                if filename in downloaded:
                  continue
                file_url = f"{base_url}/{urllib.parse.quote(filename, safe='')}"
                try:
                  download(file_url, dest_dir / f"obs-{filename}")
                except Exception:
                  continue
                downloaded.add(filename)

            if downloaded:
              break

            if time.time() + poll_interval > deadline:
              break

            print(f"OBS binaries not ready; retrying in {poll_interval}s", file=sys.stderr)
            time.sleep(poll_interval)

          if downloaded:
            print(f"Downloaded {len(downloaded)} OBS binaries")
          else:
            print(f"No OBS binaries downloaded for {package} {version}", file=sys.stderr)
          PY

      - name: Download Homebrew formula
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Update Homebrew Tap')
          }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${TAP_FORMULA_URL:-}" ]]; then
            echo "TAP_FORMULA_URL not set; skipping formula download."
            exit 0
          fi
          mkdir -p release-assets/homebrew
          curl -L --fail --show-error -o release-assets/homebrew/homebrew-homelabctl.rb "${TAP_FORMULA_URL}"

      - name: Download portable binaries
        if: >-
          ${{
            steps.release.outputs.should_upload == 'true' &&
            (github.event_name != 'workflow_run' ||
            github.event.workflow_run.name == 'Build Portable Binary')
          }}
        uses: actions/download-artifact@v4
        with:
          pattern: portable-*
          path: release-assets/portable
          merge-multiple: true
        continue-on-error: true

      - name: Upload assets to release
        if: steps.release.outputs.should_upload == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.release.outputs.tag_name }}"
          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --title "$tag" --generate-notes
          fi
          if [[ ! -d release-assets ]]; then
            echo "No assets directory to upload."
            exit 0
          fi
          mapfile -t assets < <(find release-assets -maxdepth 3 -type f | sort)
          if [[ ${#assets[@]} -eq 0 ]]; then
            echo "No assets to upload."
            exit 0
          fi
          gh release upload "$tag" "${assets[@]}" --clobber
